{"ast":null,"code":"import { IDBPDatabase, openDB } from 'idb';\nexport const indexDatabase = () => {\n  const dbName = \"the_name\";\n  const request = indexedDB.open(dbName, 2);\n\n  request.onerror = event => {// Handle errors.\n  };\n\n  request.onupgradeneeded = event => {\n    const db = event.target.result;\n    const customerData = [{\n      ssn: \"444-44-4444\",\n      name: \"Bill\",\n      age: 35,\n      email: \"bill@company.com\"\n    }, {\n      ssn: \"555-55-5555\",\n      name: \"Donna\",\n      age: 32,\n      email: \"donna@home.org\"\n    }]; // Create an objectStore to hold information about our customers. We're\n    // going to use \"ssn\" as our key path because it's guaranteed to be\n    // unique - or at least that's what I was told during the kickoff meeting.\n\n    const objectStore = db.createObjectStore(\"customers\", {\n      keyPath: \"ssn\"\n    }); // Create an index to search customers by name. We may have duplicates\n    // so we can't use a unique index.\n\n    objectStore.createIndex(\"name\", \"name\", {\n      unique: false\n    }); // // Create an index to search customers by email. We want to ensure that\n    // // no two customers have the same email, so use a unique index.\n    // objectStore.createIndex(\"email\", \"email\", { unique: true });\n    // Use transaction oncomplete to make sure the objectStore creation is\n    // finished before adding data into it.\n\n    objectStore.transaction.oncomplete = event => {\n      // Store values in the newly created objectStore.\n      const customerObjectStore = db.transaction(\"customers\", \"readwrite\").objectStore(\"customers\");\n      customerData.forEach(customer => {\n        customerObjectStore.add(customer);\n      });\n    };\n  };\n}; //export default indexDatabase","map":{"version":3,"names":["IDBPDatabase","openDB","indexDatabase","dbName","request","indexedDB","open","onerror","event","onupgradeneeded","db","target","result","customerData","ssn","name","age","email","objectStore","createObjectStore","keyPath","createIndex","unique","transaction","oncomplete","customerObjectStore","forEach","customer","add"],"sources":["D:/OliverPOS/OliverPOS3.0/src/components/indexDb.js"],"sourcesContent":["\r\nimport { IDBPDatabase, openDB } from 'idb';\r\n\r\nexport const indexDatabase = () => {\r\n    const dbName = \"the_name\";\r\n\r\n    const request = indexedDB.open(dbName, 2);\r\n\r\n    request.onerror = (event) => {\r\n        // Handle errors.\r\n    };\r\n    request.onupgradeneeded = (event) => {\r\n        const db = event.target.result;\r\n        const customerData = [\r\n            { ssn: \"444-44-4444\", name: \"Bill\", age: 35, email: \"bill@company.com\" },\r\n            { ssn: \"555-55-5555\", name: \"Donna\", age: 32, email: \"donna@home.org\" }\r\n        ];\r\n        // Create an objectStore to hold information about our customers. We're\r\n        // going to use \"ssn\" as our key path because it's guaranteed to be\r\n        // unique - or at least that's what I was told during the kickoff meeting.\r\n        const objectStore = db.createObjectStore(\"customers\", { keyPath: \"ssn\" });\r\n\r\n        // Create an index to search customers by name. We may have duplicates\r\n        // so we can't use a unique index.\r\n        objectStore.createIndex(\"name\", \"name\", { unique: false });\r\n\r\n        // // Create an index to search customers by email. We want to ensure that\r\n        // // no two customers have the same email, so use a unique index.\r\n        // objectStore.createIndex(\"email\", \"email\", { unique: true });\r\n\r\n        // Use transaction oncomplete to make sure the objectStore creation is\r\n        // finished before adding data into it.\r\n        objectStore.transaction.oncomplete = (event) => {\r\n            // Store values in the newly created objectStore.\r\n            const customerObjectStore = db.transaction(\"customers\", \"readwrite\").objectStore(\"customers\");\r\n            customerData.forEach((customer) => {\r\n                customerObjectStore.add(customer);\r\n            });\r\n        };\r\n    };\r\n}\r\n//export default indexDatabase"],"mappings":"AACA,SAASA,YAAT,EAAuBC,MAAvB,QAAqC,KAArC;AAEA,OAAO,MAAMC,aAAa,GAAG,MAAM;EAC/B,MAAMC,MAAM,GAAG,UAAf;EAEA,MAAMC,OAAO,GAAGC,SAAS,CAACC,IAAV,CAAeH,MAAf,EAAuB,CAAvB,CAAhB;;EAEAC,OAAO,CAACG,OAAR,GAAmBC,KAAD,IAAW,CACzB;EACH,CAFD;;EAGAJ,OAAO,CAACK,eAAR,GAA2BD,KAAD,IAAW;IACjC,MAAME,EAAE,GAAGF,KAAK,CAACG,MAAN,CAAaC,MAAxB;IACA,MAAMC,YAAY,GAAG,CACjB;MAAEC,GAAG,EAAE,aAAP;MAAsBC,IAAI,EAAE,MAA5B;MAAoCC,GAAG,EAAE,EAAzC;MAA6CC,KAAK,EAAE;IAApD,CADiB,EAEjB;MAAEH,GAAG,EAAE,aAAP;MAAsBC,IAAI,EAAE,OAA5B;MAAqCC,GAAG,EAAE,EAA1C;MAA8CC,KAAK,EAAE;IAArD,CAFiB,CAArB,CAFiC,CAMjC;IACA;IACA;;IACA,MAAMC,WAAW,GAAGR,EAAE,CAACS,iBAAH,CAAqB,WAArB,EAAkC;MAAEC,OAAO,EAAE;IAAX,CAAlC,CAApB,CATiC,CAWjC;IACA;;IACAF,WAAW,CAACG,WAAZ,CAAwB,MAAxB,EAAgC,MAAhC,EAAwC;MAAEC,MAAM,EAAE;IAAV,CAAxC,EAbiC,CAejC;IACA;IACA;IAEA;IACA;;IACAJ,WAAW,CAACK,WAAZ,CAAwBC,UAAxB,GAAsChB,KAAD,IAAW;MAC5C;MACA,MAAMiB,mBAAmB,GAAGf,EAAE,CAACa,WAAH,CAAe,WAAf,EAA4B,WAA5B,EAAyCL,WAAzC,CAAqD,WAArD,CAA5B;MACAL,YAAY,CAACa,OAAb,CAAsBC,QAAD,IAAc;QAC/BF,mBAAmB,CAACG,GAApB,CAAwBD,QAAxB;MACH,CAFD;IAGH,CAND;EAOH,CA5BD;AA6BH,CArCM,C,CAsCP"},"metadata":{},"sourceType":"module"}